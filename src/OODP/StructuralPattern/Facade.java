package OODP.StructuralPattern;

/**
 * Created by kushaln on 4/29/2018.
 */
/*
Adapter or Wrapper	Converts one interface to another so that it matches what the client is expecting
Decorator	Dynamically adds responsibility to the interface by wrapping the original code
Delegation	Support "composition over inheritance"
Facade	Provides a simplified interface
Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

Wrap a complicated subsystem with a simpler interface.

What problems can the Facade design pattern solve? [2]

To make a complex subsystem easier to use, a simple interface should be provided for a set of interfaces in the subsystem.
The dependencies on a subsystem should be minimized.

A Facade is used when an easier or simpler interface to an underlying object is desired.[3]
Alternatively, an adapter can be used when the wrapper must respect a particular interface and must support polymorphic behavior.
A decorator makes it possible to add or alter behavior of an interface at run-time.

make a software library easier to use, understand, and test, since the facade has convenient methods for common tasks
make the library more readable, for the same reason
reduce dependencies of outside code on the inner workings of a library, since most code uses the facade, thus allowing more flexibility in developing the system
wrap a poorly-designed collection of APIs with a single well-designed API

 */
public class Facade {
}
